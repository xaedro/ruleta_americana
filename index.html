<!-- 
<!DOCTYPE html>
<html>
<head>
  <title>Ruleta Digital Promocion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    #main-container, #capture-controls { display: none; }
    #login-container { text-align: center; margin-top: 50px; }
    .video-container {
      background-color: #000;
      position: relative;
      box-sizing: border-box;
    }
    #live-stream {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
    }
    .video-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #888;
      font-size: 1.5em;
      text-align: center;
    }
    #welcome-container {
      display: none;
      text-align: center;
      margin-top: 50px;
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 8px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    #enter-game-button {
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      color: white;
      background-color: #007bff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 20px;
    }
    #enter-game-button:hover {
      background-color: #0056b3;
    }
    h3 {
      text-align: center;
    }
    #datetime-div {
      position: fixed;
      top: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 20px;
      z-index: 1000;
      cursor: move;
      user-select: none;
      width: 200px;
      text-align: center;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div id="login-container">
    <h1>Bienvenido a Ruleta Digital Promocion</h1>
    <p>Por favor, ingresa tu nombre para continuar.</p>
    <form id="login-form">
      <input type="text" id="name-input" placeholder="Tu nombre" required>
      <button type="submit">Ingresar</button>
    </form>
  </div>
  <div id="welcome-container">
    <button id="enter-game-button">ENTRAR AL JUEGO</button>
  </div>
  <div id="main-container">
    <h3>Ruleta Digital Promocion</h3>
    <div id="capture-controls">
      <button id="startButton">INICIAR TRANSMISIÓN</button>
    </div>
    <div class="video-container">
      <video id="live-stream" autoplay muted playsinline></video>
      <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
    </div>
    <br>
    <form onsubmit="sendMessage(event)">
      <label>Realiza tu apuesta: <strong id="nombre-logueado"></strong></label>
      <input type="number" id="apuesta" placeholder="Número de apuesta" autocomplete="off" min="0" max="36" required/>
      <button id="btnEnviarApuesta" disabled>Enviar</button>
    </form>
    <ul id="messages"></ul>
  </div>
  <div id="datetime-div">Fecha y Hora: --/--/---- --:--:-- --</div>

  <script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const messagesElem = document.getElementById('messages');
    const nombreLogueadoElem = document.getElementById('nombre-logueado');
    const btnEnviarApuesta = document.getElementById('btnEnviarApuesta');
    const welcomeContainer = document.getElementById('welcome-container');
    const enterGameButton = document.getElementById('enter-game-button');
    const videoContainer = document.querySelector('.video-container');
    const datetimeDiv = document.getElementById('datetime-div');

    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = '';
    const pendingCandidates = {};
    let heartbeatInterval;

    // Configuración WebRTC
    const configuration = {
      iceServers: [
        { urls: "stun:relay1.expressturn.com:3478" },
        { urls: "stun:global.expressturn.com:3478" },
        {
          urls: [
            "turn:relay1.expressturn.com:3478?transport=tcp",
            "turn:relay1.expressturn.com:443?transport=tcp",
            "turn:global.expressturn.com:3478?transport=tcp"
          ],
          username: "000000002069365339",
          credential: "UFUNfwsJ47YX6sDdFHuqnF9U99I="
        },
        {
          urls: [
            "turn:relay2.expressturn.com:3478?transport=tcp",
            "turn:relay3.expressturn.com:3478?transport=tcp"
          ],
          username: "000000002069365339",
          credential: "UFUNfwsJ47YX6sDdFHuqnF9U99I="
        }
      ]
    };

    // Manejo de Fecha y Hora local
    document.addEventListener('DOMContentLoaded', () => {
      function updateDateTime() {
        const now = new Date();
        const date = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear()}`;
        const hours = now.getHours() % 12 || 12;
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const ampm = now.getHours() >= 12 ? 'PM' : 'AM';
        datetimeDiv.textContent = `Fecha: ${date} ${hours}:${minutes}:${seconds} ${ampm}`;
      }

      setInterval(updateDateTime, 1000);
      updateDateTime();

      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;

      datetimeDiv.addEventListener('mousedown', (e) => {
        isDragging = true;
        const rect = datetimeDiv.getBoundingClientRect();
        currentX = rect.left;
        currentY = rect.top;
        initialX = e.clientX - currentX;
        initialY = e.clientY - currentY;
        datetimeDiv.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          datetimeDiv.style.left = `${currentX}px`;
          datetimeDiv.style.top = `${currentY}px`;
          datetimeDiv.style.transform = 'none';
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        datetimeDiv.style.cursor = 'move';
      });

      function centerDiv() {
        const windowWidth = window.innerWidth;
        const divWidth = datetimeDiv.offsetWidth;
        currentX = (windowWidth - divWidth) / 2;
        currentY = 10;
        datetimeDiv.style.left = `${currentX}px`;
        datetimeDiv.style.top = `${currentY}px`;
        datetimeDiv.style.transform = 'none';
      }

      centerDiv();
      window.addEventListener('resize', centerDiv);
    });

    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
      event.preventDefault();
      const username = nameInput.value.trim();
      if (username) {
        if (!ws || ws.readyState === WebSocket.CLOSED) {
          currentUsername = username;
          connectWebSocket(username);
        } else {
          console.log("Ya se está intentando una conexión.");
        }
      } else {
        alert("Por favor, ingresa un nombre.");
      }
    };

    enterGameButton.onclick = () => {
      console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
      welcomeContainer.style.display = 'none';
      mainContainer.style.display = 'block';
      nombreLogueadoElem.textContent = currentUsername;
      if (userRole === 'streamer') {
        captureControls.style.display = 'block';
      }
      if (userRole === 'viewer' && isStreaming) {
        console.log("Stream ya está activo. Iniciando visualización...");
        startViewing();
      }
    };

    startButton.onclick = async () => {
      startButton.disabled = true;
      startButton.textContent = "CARGANDO...";
      try {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
          console.log("Stream anterior liberado.");
        }
        Object.values(peerConnections).forEach(pc => pc.close());
        peerConnections = {};
        showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());
        if (localStream.getVideoTracks().length === 0) {
          showPlaceholder("No se detectó video. Verifica OBS.");
          alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
          isStreaming = false;
          startButton.disabled = false;
          startButton.textContent = "INICIAR TRANSMISIÓN";
          return;
        }
        liveStreamVideo.srcObject = localStream;
        liveStreamVideo.muted = true;
        showStream();
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          const settings = videoTrack.getSettings();
          const width = settings.width;
          const height = settings.height;
          const aspectRatio = width / height;
          console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
          videoContainer.style.width = `${width}px`;
          videoContainer.style.aspectRatio = aspectRatio;
          ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername, video_dimensions: { width, height, aspectRatio } }));
        }
        setTimeout(() => {
          if (isStreaming) {
            startButton.disabled = false;
            startButton.textContent = "CAMBIAR FUENTE";
          }
        }, 5000);
        localStream.getVideoTracks()[0].onended = () => {
          console.log("Stream detenido por el usuario");
          ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
          isStreaming = false;
          startButton.disabled = false;
          startButton.textContent = "INICIAR TRANSMISIÓN";
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
          Object.values(peerConnections).forEach(pc => pc.close());
          peerConnections = {};
          showPlaceholder("Transmisión finalizada.");
        };
      } catch (err) {
        console.error("Error al capturar la cámara virtual de OBS:", err);
        showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
        alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
        isStreaming = false;
        startButton.disabled = false;
        startButton.textContent = "INICIAR TRANSMISIÓN";
      }
    };

    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
      console.log("Intentando conectar WebSocket...");
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      //const wsHost = process.env.NODE_ENV === 'production' ? 'ruletaamericana.up.railway.app' : 'localhost:8000';
      const wsHost = window.location.host;
      ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

      let retryCount = 0;
      const maxRetries = 5;

      ws.onopen = () => {
        console.log("Conectado al servidor. WebSocket está en estado OPEN.");
        ws.send(JSON.stringify({ type: "login", name: username }));
        retryCount = 0;
        heartbeatInterval = setInterval(() => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'ping' }));
          }
        }, 10000);
      };

      ws.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'pong') return;
          console.log("Mensaje recibido:", data);

          switch (data.type) {
            case 'login_success':
              userRole = data.role;
              streamerId = data.streamer_id || '';
              console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
              if (!streamerId && userRole === 'viewer') {
                console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
                showPlaceholder("No hay streamer disponible.");
              }
              loginContainer.style.display = 'none';
              welcomeContainer.style.display = 'block';
              nombreLogueadoElem.textContent = currentUsername;
              break;

            case 'stream_started':
              isStreaming = true;
              console.log("Stream iniciado. Estado isStreaming:", isStreaming);
              if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                showStream();
                startViewing();
                if (data.video_dimensions && data.video_dimensions.width && data.video_dimensions.height) {
                  const { width, height, aspectRatio } = data.video_dimensions;
                  console.log(`[Viewer] Dimensiones recibidas: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                  if (width > 0 && height > 0 && !isNaN(aspectRatio)) {
                    videoContainer.style.width = `${width}px`;
                    videoContainer.style.aspectRatio = aspectRatio;
                  } else {
                    console.warn("Dimensiones inválidas recibidas:", data.video_dimensions);
                    videoContainer.style.width = '640px';
                    videoContainer.style.aspectRatio = '4/3';
                  }
                } else {
                  console.warn("No se recibieron dimensiones en stream_started.");
                  videoContainer.style.width = '640px';
                  videoContainer.style.aspectRatio = '4/3';
                }
              }
              break;

            case 'stream_ended':
              isStreaming = false;
              console.log("Stream finalizado. Estado isStreaming:", isStreaming);
              showPlaceholder("La transmisión ha finalizado.");
              if (userRole === 'streamer') {
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                if (localStream) localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
              } else {
                if (peerConnection) peerConnection.close();
                peerConnection = null;
                liveStreamVideo.srcObject = null;
              }
              break;

            case 'game_event':
              switch (data.payload) {
                case 'game_started':
                  console.log("El juego ha comenzado");
                  btnEnviarApuesta.disabled = false;
                  break;
                case 'game_ended':
                  console.log("El juego ha terminado");
                  btnEnviarApuesta.disabled = true;
                  break;
                case 'bets_open':
                  console.log("Apuestas abiertas");
                  btnEnviarApuesta.disabled = false;
                  break;
                case 'bets_closed':
                  console.log("Apuestas cerradas");
                  btnEnviarApuesta.disabled = true;
                  break;
              }
              break;

            case 'fecha_hora':
              console.log("Fecha y hora:", data.payload);
              datetimeDiv.textContent = `Fecha y Hora: ${data.payload}`;
              break;

            case 'juego_numero':
              console.log("Consecutivo del juego:", data.payload);
              // Añadir lógica para mostrar consecutive_id en la interfaz
              const consecutivoLi = document.createElement('li');
              consecutivoLi.textContent = `Consecutivo: ${data.payload}`;
              messagesElem.appendChild(consecutivoLi);
              break;

            case 'numero_caido':
              console.log("Número ganador:", data.payload);
              const numeroLi = document.createElement('li');
              numeroLi.textContent = `Número caído: ${data.payload}`;
              messagesElem.appendChild(numeroLi);
              break;

            case 'usuarios_conectados':
              console.log("Usuarios conectados:", data.payload);
              const usuariosLi = document.createElement('li');
              usuariosLi.textContent = `Usuarios conectados: ${data.payload}`;
              messagesElem.appendChild(usuariosLi);
              break;

            case 'offer':
              if (userRole === 'streamer') {
                console.log(`Oferta recibida de ${data.from_id}`);
                await handleOffer(data.offer, data.from_id);
              }
              break;

            case 'answer':
              if (userRole === 'viewer') {
                console.log(`Respuesta recibida de streamer`);
                await handleAnswer(data.answer, data.from_id);
              }
              break;

            case 'candidate':
              console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
              await handleCandidate(data.candidate, data.from_id);
              break;

            default:
              console.log("Mensaje JSON desconocido:", data);
          }
        } catch (e) {
          console.error("Error al parsear mensaje WebSocket:", e);
        }
      };

      ws.onclose = (event) => {
        console.log(`Conexión cerrada. Código: ${event.code}, Razón: ${event.reason}`);
        clearInterval(heartbeatInterval);
        ws = null;
        if (retryCount < maxRetries) {
          retryCount++;
          const delay = 3000 * retryCount + (Math.random() * 100);
          console.log(`Reintentando conexión (${retryCount}/${maxRetries}) en ${delay}ms...`);
          setTimeout(() => connectWebSocket(username), delay);
        } else {
          loginContainer.style.display = 'block';
          mainContainer.style.display = 'none';
          welcomeContainer.style.display = 'none';
          alert("Se ha perdido la conexión con el servidor. Por favor, recarga la página.");
        }
      };

      ws.onerror = (error) => {
        console.error("Error en WebSocket:", error);
      };
    }

    // Funciones para enviar eventos (solo el streamer)
    function sendGameEvent(event) {
      if (["game_started", "game_ended", "bets_open", "bets_closed"].includes(event)) {
        ws.send(JSON.stringify({ type: "game_event", content: event }));
      } else {
        console.error("Evento de juego inválido:", event);
      }
    }

    function sendFechaHora(fechaHora) {
      ws.send(JSON.stringify({ type: "fecha_hora", fecha_hora_str: fechaHora }));
    }

    function sendConsecutivoJuego(consecutiveId) {
      ws.send(JSON.stringify({ type: "consecutivo_juego", consecutive_id: Number(consecutiveId) }));
    }

    function sendNumeroCaido(numero) {
      ws.send(JSON.stringify({ type: "numero_caido", numero: Number(numero) }));
    }

    // LÓGICA DE WEBRTC
    async function startViewing() {
      if (!streamerId) {
        console.error("No se ha recibido el ID del streamer.");
        showPlaceholder("No hay streamer disponible.");
        return;
      }
      try {
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
          console.log("Conexión WebRTC anterior cerrada.");
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);
        pendingCandidates['viewer'] = [];
        peerConnection.ontrack = (event) => {
          console.log("-> EVENTO ONTRACK DISPARADO");
          const remoteStream = event.streams[0];
          console.log("Pistas de video:", remoteStream.getVideoTracks());
          console.log("Pistas de audio:", remoteStream.getAudioTracks());
          if (liveStreamVideo.srcObject !== remoteStream) {
            console.log("Asignando nuevo stream al elemento de video.");
            liveStreamVideo.srcObject = remoteStream;
          }
          liveStreamVideo.muted = true;
          liveStreamVideo.playsInline = true;
          const playVideo = () => {
            liveStreamVideo.play().then(() => {
              console.log("¡Reproducción iniciada!");
              showStream();
            }).catch(error => {
              console.error("Error al reproducir video:", error);
              showPlaceholder("Haz clic para reproducir la transmisión.");
              liveStreamVideo.addEventListener('click', playVideo, { once: true });
            });
          };
          playVideo();
        };
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            console.log('Enviando candidato ICE:', event.candidate);
            ws.send(JSON.stringify({
              type: 'candidate',
              candidate: event.candidate,
              target_id: streamerId,
              from_id: currentUsername
            }));
          }
        };
        peerConnection.oniceconnectionstatechange = () => {
          console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
          if (peerConnection.iceConnectionState === 'failed') {
            console.error("Fallo en la conexión ICE. Detalles:", {
              iceConnectionState: peerConnection.iceConnectionState,
              iceGatheringState: peerConnection.iceGatheringState,
              signalingState: peerConnection.signalingState
            });
            showPlaceholder("Error de conexión WebRTC. Intenta de nuevo.");
            peerConnection.restartIce();
          }
        };
        peerConnection.addTransceiver('video', { direction: 'recvonly' });
        peerConnection.addTransceiver('audio', { direction: 'recvonly' });
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        console.log("Oferta enviada:", offer);
        ws.send(JSON.stringify({
          type: 'offer',
          offer: { type: offer.type, sdp: offer.sdp },
          from_id: currentUsername,
          target_id: streamerId
        }));
        if (pendingCandidates['viewer'].length > 0) {
          console.log("Procesando candidatos pendientes para viewer...");
          for (const candidate of pendingCandidates['viewer']) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log("Candidato ICE añadido para viewer");
          }
          pendingCandidates['viewer'] = [];
        }
      } catch (error) {
        console.error("Error en startViewing:", error);
        showPlaceholder("Error al conectar con el streamer.");
      }
    }

    async function handleOffer(offer, viewerId) {
      console.log(`Manejando oferta de ${viewerId}`);
      if (peerConnections[viewerId]) {
        peerConnections[viewerId].close();
        delete peerConnections[viewerId];
        console.log(`Conexión WebRTC anterior para ${viewerId} cerrada.`);
      }
      const pc = new RTCPeerConnection(configuration);
      peerConnections[viewerId] = pc;
      pendingCandidates[viewerId] = [];
      pc.onicecandidate = event => {
        if (event.candidate) {
          console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
          ws.send(JSON.stringify({
            type: 'candidate',
            candidate: event.candidate,
            target_id: viewerId,
            from_id: currentUsername
          }));
        }
      };
      pc.onconnectionstatechange = () => {
        console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        if (pc.connectionState === 'failed') {
          console.error("Fallo en conexión WebRTC para", viewerId, {
            iceConnectionState: pc.iceConnectionState,
            iceGatheringState: pc.iceGatheringState,
            signalingState: pc.signalingState
          });
          pc.close();
          delete peerConnections[viewerId];
          console.log(`Conexión WebRTC para ${viewerId} cerrada por fallo.`);
        }
      };
      try {
        if (!offer || !offer.sdp || typeof offer.sdp !== 'string') {
          throw new Error(`Invalid SDP in offer from ${viewerId}`);
        }
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        console.log(`remoteDescription configurada para ${viewerId}`);
        if (localStream) {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
          });
        } else {
          console.error("No hay localStream disponible.");
          return;
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log(`Respuesta enviada para ${viewerId}:`, answer);
        ws.send(JSON.stringify({
          type: 'answer',
          answer: { type: answer.type, sdp: answer.sdp },
          target_id: viewerId,
          from_id: currentUsername
        }));
        if (pendingCandidates[viewerId].length > 0) {
          console.log(`Procesando candidatos pendientes para ${viewerId}...`);
          for (const candidate of pendingCandidates[viewerId]) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Candidato ICE añadido para ${viewerId}`);
          }
          pendingCandidates[viewerId] = [];
        }
      } catch (error) {
        console.error(`Error manejando oferta de ${viewerId}:`, error);
        pc.close();
        delete peerConnections[viewerId];
      }
    }

    async function handleAnswer(answer, fromId) {
      const pc = peerConnection;
      if (pc) {
        try {
          if (!answer || !answer.sdp || typeof answer.sdp !== 'string') {
            throw new Error(`Invalid SDP in answer from ${fromId}`);
          }
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
          console.log(`remoteDescription configurada para respuesta de ${fromId}`);
          if (pendingCandidates['viewer'].length > 0) {
            console.log(`Procesando candidatos pendientes para viewer...`);
            for (const candidate of pendingCandidates['viewer']) {
              await pc.addIceCandidate(new RTCIceCandidate(candidate));
              console.log(`Candidato ICE añadido para viewer`);
            }
            pendingCandidates['viewer'] = [];
          }
        } catch (error) {
          console.error(`Error manejando respuesta de ${fromId}:`, error);
        }
      } else {
        console.warn(`No se encontró peerConnection para el viewer`);
      }
    }

    async function handleCandidate(candidate, fromId) {
      const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
      if (pc) {
        try {
          if (!candidate || (!candidate.candidate && candidate.candidate !== '')) {
            console.warn(`Candidato ICE inválido de ${fromId}:`, candidate);
            return;
          }
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Candidato ICE añadido para ${fromId}`);
          } else {
            console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
            if (!pendingCandidates[fromId] && userRole === 'streamer') {
              pendingCandidates[fromId] = [];
            } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
              pendingCandidates['viewer'] = [];
            }
            (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
          }
        } catch (e) {
          console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
        }
      } else {
        console.warn(`No se encontró peerConnection para ${fromId}`);
      }
    }

    // Funciones de UI
    function showStream() {
      liveStreamVideo.style.visibility = 'visible';
      streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
      liveStreamVideo.style.visibility = 'hidden';
      streamPlaceholder.textContent = message;
      streamPlaceholder.style.display = 'block';
    }

    // Función para enviar mensajes de apuesta
    function sendMessage(event) {
      event.preventDefault();
      const apuestaInput = document.getElementById('apuesta');
      const apuesta = apuestaInput.value;
      if (apuesta && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(`Apuesta de ${currentUsername}: ${apuesta}`);
        apuestaInput.value = '';
      } else {
        console.warn("WebSocket no está abierto o apuesta vacía.");
      }
    }
  </script>
</body>
</html>
-->

<!DOCTYPE html>
<html>
<head>
  <title>Ruleta Digital Promocion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    #main-container, #capture-controls { display: none; }
    #login-container { text-align: center; margin-top: 50px; }
    .video-container {
      background-color: #000;
      position: relative;
      box-sizing: border-box;
    }
    #live-stream {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
    }
    .video-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #888;
      font-size: 1.5em;
      text-align: center;
    }
    #welcome-container {
      display: none;
      text-align: center;
      margin-top: 50px;
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 8px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    #enter-game-button {
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      color: white;
      background-color: #007bff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 20px;
    }
    #enter-game-button:hover {
      background-color: #0056b3;
    }
    h3 {
      text-align: center;
    }
    #datetime-div {
      position: fixed;
      top: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 20px;
      z-index: 1000;
      cursor: move;
      user-select: none;
      width: 200px;
      text-align: center;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div id="login-container">
    <h1>Bienvenido a Ruleta Digital Promocion</h1>
    <p>Por favor, ingresa tu nombre para continuar.</p>
    <form id="login-form">
      <input type="text" id="name-input" placeholder="Tu nombre" required>
      <button type="submit">Ingresar</button>
    </form>
  </div>
  <div id="welcome-container">
    <button id="enter-game-button">ENTRAR AL JUEGO</button>
  </div>
  <div id="main-container">
    <h3>Ruleta Digital Promocion</h3>
    <div id="capture-controls">
      <button id="startButton">INICIAR TRANSMISIÓN</button>
    </div>
    <div class="video-container">
      <video id="live-stream" autoplay muted playsinline></video>
      <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
    </div>
    <br>
    <form onsubmit="sendMessage(event)">
      <label>Realiza tu apuesta: <strong id="nombre-logueado"></strong></label>
      <input type="number" id="apuesta" placeholder="Número de apuesta" autocomplete="off" min="0" max="36" required/>
      <button id="btnEnviarApuesta" disabled>Enviar</button>
    </form>
    <ul id="messages"></ul>
  </div>
  <div id="datetime-div">Fecha y Hora: --/--/---- --:--:-- --</div>

  <script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const messagesElem = document.getElementById('messages');
    const nombreLogueadoElem = document.getElementById('nombre-logueado');
    const btnEnviarApuesta = document.getElementById('btnEnviarApuesta');
    const welcomeContainer = document.getElementById('welcome-container');
    const enterGameButton = document.getElementById('enter-game-button');
    const videoContainer = document.querySelector('.video-container');
    const datetimeDiv = document.getElementById('datetime-div');

    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = '';
    const pendingCandidates = {};
    //let heartbeatInterval;

    // Configuración WebRTC
	/*
    const configuration = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        {
          urls: "turn:relay1.expressturn.com:3478?transport=tcp",
          username: "000000002069365339",
          credential: "UFUNfwsJ47YX6sDdFHuqnF9U99I="
        }
      ]
    };
    */
	
	const configuration = {
		iceServers: [
			{
				"urls": "stun:relay1.expressturn.com:3478"
			},
			{
				"urls": "turn:relay1.expressturn.com:3478?transport=tcp",
				"username": "000000002069365339",
				"credential": "UFUNfwsJ47YX6sDdFHuqnF9U99I="
			}
		]
	};
	
    // Manejo de Fecha y Hora local
    document.addEventListener('DOMContentLoaded', () => {
      function updateDateTime() {
        const now = new Date();
        const date = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear()}`;
        const hours = now.getHours() % 12 || 12;
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const ampm = now.getHours() >= 12 ? 'PM' : 'AM';
        datetimeDiv.textContent = `Fecha: ${date} ${hours}:${minutes}:${seconds} ${ampm}`;
      }

      setInterval(updateDateTime, 1000);
      updateDateTime();

      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;

      datetimeDiv.addEventListener('mousedown', (e) => {
        isDragging = true;
        const rect = datetimeDiv.getBoundingClientRect();
        currentX = rect.left;
        currentY = rect.top;
        initialX = e.clientX - currentX;
        initialY = e.clientY - currentY;
        datetimeDiv.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          datetimeDiv.style.left = `${currentX}px`;
          datetimeDiv.style.top = `${currentY}px`;
          datetimeDiv.style.transform = 'none';
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        datetimeDiv.style.cursor = 'move';
      });

      function centerDiv() {
        const windowWidth = window.innerWidth;
        const divWidth = datetimeDiv.offsetWidth;
        currentX = (windowWidth - divWidth) / 2;
        currentY = 10;
        datetimeDiv.style.left = `${currentX}px`;
        datetimeDiv.style.top = `${currentY}px`;
        datetimeDiv.style.transform = 'none';
      }

      centerDiv();
      window.addEventListener('resize', centerDiv);
    });

    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
      event.preventDefault();
      const username = nameInput.value.trim();
      if (username) {
        if (!ws || ws.readyState === WebSocket.CLOSED) {
          currentUsername = username;
          connectWebSocket(username);
        } else {
          console.log("Ya se está intentando una conexión.");
        }
      } else {
        alert("Por favor, ingresa un nombre.");
      }
    };

    enterGameButton.onclick = () => {
      console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
      welcomeContainer.style.display = 'none';
      mainContainer.style.display = 'block';
      nombreLogueadoElem.textContent = currentUsername;
      if (userRole === 'streamer') {
        captureControls.style.display = 'block';
      }
      if (userRole === 'viewer' && isStreaming) {
        console.log("Stream ya está activo. Iniciando visualización...");
        startViewing();
      }
    };
	
	/*
    startButton.onclick = async () => {
      startButton.disabled = true;
      startButton.textContent = "CARGANDO...";
      try {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
          console.log("Stream anterior liberado.");
        }
        Object.values(peerConnections).forEach(pc => pc.close());
        peerConnections = {};
        showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());
        if (localStream.getVideoTracks().length === 0) {
          showPlaceholder("No se detectó video. Verifica OBS.");
          alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
          isStreaming = false;
          startButton.disabled = false;
          startButton.textContent = "INICIAR TRANSMISIÓN";
          return;
        }
        liveStreamVideo.srcObject = localStream;
        liveStreamVideo.muted = true;
        showStream();
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          const settings = videoTrack.getSettings();
          const width = settings.width;
          const height = settings.height;
          const aspectRatio = width / height;
          console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
          videoContainer.style.width = `${width}px`;
          videoContainer.style.aspectRatio = aspectRatio;
          ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername, video_dimensions: { width, height, aspectRatio } }));
        }
        setTimeout(() => {
          if (isStreaming) {
            startButton.disabled = false;
            startButton.textContent = "CAMBIAR FUENTE";
          }
        }, 5000);
        localStream.getVideoTracks()[0].onended = () => {
          console.log("Stream detenido por el usuario");
          ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
          isStreaming = false;
          startButton.disabled = false;
          startButton.textContent = "INICIAR TRANSMISIÓN";
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
          Object.values(peerConnections).forEach(pc => pc.close());
          peerConnections = {};
          showPlaceholder("Transmisión finalizada.");
        };
      } catch (err) {
        console.error("Error al capturar la cámara virtual de OBS:", err);
        showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
        alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
        isStreaming = false;
        startButton.disabled = false;
        startButton.textContent = "INICIAR TRANSMISIÓN";
      }
    };
	*/
	
	startButton.onclick = async () => {
		startButton.disabled = true;
		startButton.textContent = "CARGANDO...";
		try {
			if (localStream) {
				localStream.getTracks().forEach(track => track.stop());
				localStream = null;
				console.log("Stream anterior liberado.");
			}
			Object.values(peerConnections).forEach(pc => pc.close());
			peerConnections = {};
			showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");
			console.log("Solicitando acceso a cámara/micrófono...");
			localStream = await navigator.mediaDevices.getUserMedia({
				video: true,
				audio: true
			});
			console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());
			if (localStream.getVideoTracks().length === 0) {
				console.error("No se detectó video. Verifica OBS.");
				showPlaceholder("No se detectó video. Verifica OBS.");
				alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
				isStreaming = false;
				startButton.disabled = false;
				startButton.textContent = "INICIAR TRANSMISIÓN";
				return;
			}
			liveStreamVideo.srcObject = localStream;
			liveStreamVideo.muted = true;
			showStream();
			isStreaming = true; // Establecer isStreaming a true aquí
			const videoTrack = localStream.getVideoTracks()[0];
			if (videoTrack) {
				const settings = videoTrack.getSettings();
				const width = settings.width;
				const height = settings.height;
				const aspectRatio = width / height;
				console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
				videoContainer.style.width = `${width}px`;
				videoContainer.style.aspectRatio = aspectRatio;
				console.log("Enviando mensaje start_stream...");
				ws.send(JSON.stringify({
					type: 'start_stream',
					from_id: currentUsername,
					video_dimensions: { width, height, aspectRatio }
				}));
				console.log("Mensaje start_stream enviado con éxito");
			}
			setTimeout(() => {
				if (isStreaming) {
					startButton.disabled = false;
					startButton.textContent = "CAMBIAR FUENTE";
				}
			}, 5000);
			localStream.getVideoTracks()[0].onended = () => {
				console.log("Stream detenido por el usuario");
				ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
				isStreaming = false;
				startButton.disabled = false;
				startButton.textContent = "INICIAR TRANSMISIÓN";
				localStream.getTracks().forEach(track => track.stop());
				localStream = null;
				Object.values(peerConnections).forEach(pc => pc.close());
				peerConnections = {};
				showPlaceholder("Transmisión finalizada.");
			};
		} catch (err) {
			console.error("Error al capturar la cámara virtual de OBS:", err);
			showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
			alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
			isStreaming = false;
			startButton.disabled = false;
			startButton.textContent = "INICIAR TRANSMISIÓN";
		}
	};
    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
      console.log("Intentando conectar WebSocket...");
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsHost = window.location.host;
      ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

      let retryCount = 0;
      const maxRetries = 5;

      ws.onopen = () => {
        console.log("Conectado al servidor. WebSocket está en estado OPEN.");
        ws.send(JSON.stringify({ type: "login", name: username }));
        retryCount = 0;
        heartbeatInterval = setInterval(() => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'ping' }));
          }
        }, 10000);
      };

      ws.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'pong') return;
          console.log("Mensaje recibido:", data);

          switch (data.type) {
			/*
            case 'login_success':
              userRole = data.role;
              streamerId = data.streamer_id || '';
              console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
              if (!streamerId && userRole === 'viewer') {
                console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
                showPlaceholder("No hay streamer disponible.");
              }
              loginContainer.style.display = 'none';
              welcomeContainer.style.display = 'block';
              nombreLogueadoElem.textContent = currentUsername;
              break;
			*/
			case 'login_success':
				userRole = data.role;
				streamerId = data.streamer_id || '';
				console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
				loginContainer.style.display = 'none';
				welcomeContainer.style.display = 'block';
				nombreLogueadoElem.textContent = currentUsername;
				if (userRole === 'viewer' && streamerId) {
					console.log("Iniciando visualización para espectador con streamer_id:", streamerId);
					startViewing();
				} else if (!streamerId && userRole === 'viewer') {
					console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
					showPlaceholder("No hay streamer disponible.");
				}
				break;
            case 'stream_started':
              isStreaming = true;
              console.log("Stream iniciado. Estado isStreaming:", isStreaming);
              if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                showStream();
                startViewing();
                if (data.video_dimensions && data.video_dimensions.width && data.video_dimensions.height) {
                  const { width, height, aspectRatio } = data.video_dimensions;
                  console.log(`[Viewer] Dimensiones recibidas: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                  if (width > 0 && height > 0 && !isNaN(aspectRatio)) {
                    videoContainer.style.width = `${width}px`;
                    videoContainer.style.aspectRatio = aspectRatio;
                  } else {
                    console.warn("Dimensiones inválidas recibidas:", data.video_dimensions);
                    videoContainer.style.width = '640px';
                    videoContainer.style.aspectRatio = '4/3';
                  }
                } else {
                  console.warn("No se recibieron dimensiones en stream_started.");
                  videoContainer.style.width = '640px';
                  videoContainer.style.aspectRatio = '4/3';
                }
              }
              break;

            case 'stream_ended':
              isStreaming = false;
              console.log("Stream finalizado. Estado isStreaming:", isStreaming);
              showPlaceholder("La transmisión ha finalizado.");
              if (userRole === 'streamer') {
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                if (localStream) localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
              } else {
                if (peerConnection) peerConnection.close();
                peerConnection = null;
                liveStreamVideo.srcObject = null;
              }
              break;

            case 'viewer_disconnected':
              if (userRole === 'streamer') {
                const viewerId = data.viewer_id;
                console.log(`Espectador ${viewerId} desconectado.`);
                if (peerConnections[viewerId]) {
                  peerConnections[viewerId].close();
                  delete peerConnections[viewerId];
                  delete pendingCandidates[viewerId];
                  console.log(`Conexión WebRTC para ${viewerId} cerrada.`);
                }
              }
              break;

            case 'game_event':
              console.log(`Evento de juego recibido: ${data.payload}`);
              const gameEventLi = document.createElement('li');
              switch (data.payload) {
                case 'game_started':
                  console.log('game_started');
                  gameEventLi.textContent = "El juego ha comenzado";
                  btnEnviarApuesta.disabled = false;
                  break;
                case 'game_ended':
                  console.log('game_ended');
                  gameEventLi.textContent = "El juego ha terminado";
                  btnEnviarApuesta.disabled = true;
                  break;
                case 'bets_open':
                  console.log('bets_open');
                  gameEventLi.textContent = "Apuestas abiertas";
                  btnEnviarApuesta.disabled = false;
                  break;
                case 'bets_closed':
                  console.log('bets_closed');
                  gameEventLi.textContent = "Apuestas cerradas";
                  btnEnviarApuesta.disabled = true;
                  break;
                default:
                  gameEventLi.textContent = `Evento desconocido: ${data.payload}`;
              }
              messagesElem.appendChild(gameEventLi);
              break;

            case 'fecha_hora':
              console.log("Fecha y hora:", data.payload);
              datetimeDiv.textContent = `Fecha y Hora: ${data.payload}`;
              break;

            case 'juego_numero':
              console.log("Consecutivo del juego:", data.payload);
              const consecutivoLi = document.createElement('li');
              consecutivoLi.textContent = `Consecutivo: ${data.payload}`;
              messagesElem.appendChild(consecutivoLi);
              break;

            case 'numero_caido':
              console.log("Número ganador:", data.payload);
              const numeroLi = document.createElement('li');
              numeroLi.textContent = `Número caído: ${data.payload}`;
              messagesElem.appendChild(numeroLi);
              break;

            case 'apuesta':
              console.log(`Apuesta de ${data.payload.username}: ${data.payload.numero}`);
              const apuestaLi = document.createElement('li');
              apuestaLi.textContent = `Apuesta de ${data.payload.username}: ${data.payload.numero}`;
              messagesElem.appendChild(apuestaLi);
              break;

            case 'usuarios_conectados':
              console.log("Usuarios conectados:", data.payload);
              const usuariosLi = document.createElement('li');
              usuariosLi.textContent = `Usuarios conectados: ${data.payload}`;
              messagesElem.appendChild(usuariosLi);
              break;

            case 'offer':
              if (userRole === 'streamer') {
                console.log(`Oferta recibida de ${data.from_id}`);
                await handleOffer(data.offer, data.from_id);
              }
              break;

            case 'answer':
              if (userRole === 'viewer') {
                console.log(`Respuesta recibida de streamer`);
                await handleAnswer(data.answer, data.from_id);
              }
              break;

            case 'candidate':
              console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
              await handleCandidate(data.candidate, data.from_id);
              break;

            default:
              console.log("Mensaje JSON desconocido:", data);
          }
        } catch (e) {
          console.error("Error al parsear mensaje WebSocket:", e);
        }
      };

      ws.onclose = (event) => {
        console.log(`Conexión cerrada. Código: ${event.code}, Razón: ${event.reason}`);
        clearInterval(heartbeatInterval);
        ws = null;
        if (retryCount < maxRetries) {
          retryCount++;
          const delay = 3000 * retryCount + (Math.random() * 100);
          console.log(`Reintentando conexión (${retryCount}/${maxRetries}) en ${delay}ms...`);
          setTimeout(() => connectWebSocket(username), delay);
        } else {
          loginContainer.style.display = 'block';
          mainContainer.style.display = 'none';
          welcomeContainer.style.display = 'none';
          alert("Se ha perdido la conexión con el servidor. Por favor, recarga la página.");
        }
      };

      ws.onerror = (error) => {
        console.error("Error en WebSocket:", error);
      };
    }

    // Funciones para enviar eventos (solo el streamer)
    function sendGameEvent(event) {
      if (["game_started", "game_ended", "bets_open", "bets_closed"].includes(event)) {
        ws.send(JSON.stringify({ type: "game_event", content: event }));
      } else {
        console.error("Evento de juego inválido:", event);
      }
    }

    function sendFechaHora(fechaHora) {
      ws.send(JSON.stringify({ type: "fecha_hora", fecha_hora_str: fechaHora }));
    }

    function sendConsecutivoJuego(consecutiveId) {
      ws.send(JSON.stringify({ type: "consecutivo_juego", consecutive_id: Number(consecutiveId) }));
    }

    function sendNumeroCaido(numero) {
      ws.send(JSON.stringify({ type: "numero_caido", numero: Number(numero) }));
    }

    // Función para enviar mensajes de apuesta
    function sendMessage(event) {
      event.preventDefault();
      const apuestaInput = document.getElementById('apuesta');
      const apuesta = apuestaInput.value;
      if (apuesta && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "apuesta", username: currentUsername, numero: Number(apuesta) }));
        apuestaInput.value = '';
      } else {
        console.warn("WebSocket no está abierto o apuesta vacía.");
      }
    }

    // LÓGICA DE WEBRTC
	/*
    async function startViewing() {
      if (!streamerId) {
        console.error("No se ha recibido el ID del streamer.");
        showPlaceholder("No hay streamer disponible.");
        return;
      }
      try {
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
          console.log("Conexión WebRTC anterior cerrada.");
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);
        pendingCandidates['viewer'] = [];
        peerConnection.ontrack = (event) => {
          console.log("-> EVENTO ONTRACK DISPARADO");
          const remoteStream = event.streams[0];
          console.log("Pistas de video:", remoteStream.getVideoTracks());
          console.log("Pistas de audio:", remoteStream.getAudioTracks());
          if (liveStreamVideo.srcObject !== remoteStream) {
            console.log("Asignando nuevo stream al elemento de video.");
            liveStreamVideo.srcObject = remoteStream;
          }
          liveStreamVideo.muted = true;
          liveStreamVideo.playsInline = true;
          const playVideo = () => {
            liveStreamVideo.play().then(() => {
              console.log("¡Reproducción iniciada!");
              showStream();
            }).catch(error => {
              console.error("Error al reproducir video:", error);
              showPlaceholder("Haz clic para reproducir la transmisión.");
              liveStreamVideo.addEventListener('click', playVideo, { once: true });
            });
          };
          playVideo();
        };
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            console.log('Enviando candidato ICE:', event.candidate);
            ws.send(JSON.stringify({
              type: 'candidate',
              candidate: event.candidate,
              target_id: streamerId,
              from_id: currentUsername
            }));
          }
        };
        peerConnection.oniceconnectionstatechange = () => {
          console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
          if (peerConnection.iceConnectionstate === 'failed') {
            console.error("Fallo en la conexión ICE. Detalles:", {
              iceConnectionState: peerConnection.iceConnectionState,
              iceGatheringState: peerConnection.iceGatheringState,
              signalingState: peerConnection.signalingState
            });
            showPlaceholder("Error de conexión WebRTC. Intenta de nuevo.");
            peerConnection.restartIce();
          }
        };
        peerConnection.addTransceiver('video', { direction: 'recvonly' });
        peerConnection.addTransceiver('audio', { direction: 'recvonly' });
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        console.log("Oferta enviada:", offer);
        ws.send(JSON.stringify({
          type: 'offer',
          offer: { type: offer.type, sdp: offer.sdp },
          from_id: currentUsername,
          target_id: streamerId
        }));
        if (pendingCandidates['viewer'].length > 0) {
          console.log("Procesando candidatos pendientes para viewer...");
          for (const candidate of pendingCandidates['viewer']) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log("Candidato ICE añadido para viewer");
          }
          pendingCandidates['viewer'] = [];
        }
      } catch (error) {
        console.error("Error en startViewing:", error);
        showPlaceholder("Error al conectar con el streamer.");
      }
    }
	*/
	async function startViewing() {
		if (!streamerId) {
			console.error("No se ha recibido el ID del streamer.");
			showPlaceholder("No hay streamer disponible.");
			return;
		}
		try {
			if (peerConnection) {
				peerConnection.close();
				peerConnection = null;
				console.log("Conexión WebRTC anterior cerrada.");
			}
			console.log("Iniciando conexión WebRTC como espectador con streamer_id:", streamerId);
			peerConnection = new RTCPeerConnection(configuration);
			pendingCandidates['viewer'] = [];
			peerConnection.ontrack = (event) => {
				console.log("-> EVENTO ONTRACK DISPARADO");
				const remoteStream = event.streams[0];
				console.log("Pistas de video:", remoteStream.getVideoTracks());
				console.log("Pistas de audio:", remoteStream.getAudioTracks());
				if (liveStreamVideo.srcObject !== remoteStream) {
					console.log("Asignando nuevo stream al elemento de video.");
					liveStreamVideo.srcObject = remoteStream;
				}
				liveStreamVideo.muted = true;
				liveStreamVideo.playsInline = true;
				const playVideo = () => {
					liveStreamVideo.play().then(() => {
						console.log("¡Reproducción iniciada!");
						showStream();
					}).catch(error => {
						console.error("Error al reproducir video:", error);
						showPlaceholder("Haz clic para reproducir la transmisión.");
						liveStreamVideo.addEventListener('click', playVideo, { once: true });
					});
				};
				playVideo();
			};
			peerConnection.onicecandidate = (event) => {
				if (event.candidate) {
					console.log('Enviando candidato ICE:', event.candidate);
					ws.send(JSON.stringify({
						type: 'candidate',
						candidate: event.candidate,
						target_id: streamerId,
						from_id: currentUsername
					}));
				}
			};
			peerConnection.oniceconnectionstatechange = () => {
				console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
				if (peerConnection.iceConnectionState === 'failed') {
					console.error("Fallo en la conexión ICE. Detalles:", {
						iceConnectionState: peerConnection.iceConnectionState,
						iceGatheringState: peerConnection.iceGatheringState,
						signalingState: peerConnection.signalingState
					});
					showPlaceholder("Error de conexión WebRTC. Intenta de nuevo.");
					peerConnection.restartIce();
				}
			};
			console.log("Añadiendo transceivers para video y audio...");
			peerConnection.addTransceiver('video', { direction: 'recvonly' });
			peerConnection.addTransceiver('audio', { direction: 'recvonly' });
			console.log("Creando oferta WebRTC...");
			const offer = await peerConnection.createOffer();
			await peerConnection.setLocalDescription(offer);
			console.log("Oferta enviada:", offer);
			ws.send(JSON.stringify({
				type: 'offer',
				offer: { type: offer.type, sdp: offer.sdp },
				from_id: currentUsername,
				target_id: streamerId
			}));
			console.log("Oferta WebRTC enviada al streamer");
			if (pendingCandidates['viewer'].length > 0) {
				console.log("Procesando candidatos pendientes para viewer...");
				for (const candidate of pendingCandidates['viewer']) {
					await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
					console.log("Candidato ICE añadido para viewer");
				}
				pendingCandidates['viewer'] = [];
			}
		} catch (error) {
			console.error("Error en startViewing:", error);
			showPlaceholder("Error al conectar con el streamer.");
		}
	}
	
    async function handleOffer(offer, viewerId) {
      console.log(`Manejando oferta de ${viewerId}`);
      if (peerConnections[viewerId]) {
        peerConnections[viewerId].close();
        delete peerConnections[viewerId];
        console.log(`Conexión WebRTC anterior para ${viewerId} cerrada.`);
      }
      const pc = new RTCPeerConnection(configuration);
      peerConnections[viewerId] = pc;
      pendingCandidates[viewerId] = [];
      pc.onicecandidate = event => {
        if (event.candidate) {
          console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
          ws.send(JSON.stringify({
            type: 'candidate',
            candidate: event.candidate,
            target_id: viewerId,
            from_id: currentUsername
          }));
        }
      };
      pc.onconnectionstatechange = () => {
        console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        if (pc.connectionState === 'failed') {
          console.error("Fallo en conexión WebRTC para", viewerId, {
            iceConnectionState: pc.iceConnectionState,
            iceGatheringState: pc.iceGatheringState,
            signalingState: pc.signalingState
          });
          pc.close();
          delete peerConnections[viewerId];
          delete pendingCandidates[viewerId];
          console.log(`Conexión WebRTC para ${viewerId} cerrada por fallo.`);
        }
      };
      try {
        if (!offer || !offer.sdp || typeof offer.sdp !== 'string') {
          throw new Error(`Invalid SDP in offer from ${viewerId}`);
        }
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        console.log(`remoteDescription configurada para ${viewerId}`);
        if (localStream) {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
          });
        } else {
          console.error("No hay localStream disponible.");
          return;
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log(`Respuesta enviada para ${viewerId}:`, answer);
        ws.send(JSON.stringify({
          type: 'answer',
          answer: { type: answer.type, sdp: answer.sdp },
          target_id: viewerId,
          from_id: currentUsername
        }));
        if (pendingCandidates[viewerId].length > 0) {
          console.log(`Procesando candidatos pendientes para ${viewerId}...`);
          for (const candidate of pendingCandidates[viewerId]) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Candidato ICE añadido para ${viewerId}`);
          }
          pendingCandidates[viewerId] = [];
        }
      } catch (error) {
        console.error(`Error manejando oferta de ${viewerId}:`, error);
        pc.close();
        delete peerConnections[viewerId];
        delete pendingCandidates[viewerId];
      }
    }

    async function handleAnswer(answer, fromId) {
      const pc = peerConnection;
      if (pc) {
        try {
          if (!answer || !answer.sdp || typeof answer.sdp !== 'string') {
            throw new Error(`Invalid SDP in answer from ${fromId}`);
          }
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
          console.log(`remoteDescription configurada para respuesta de ${fromId}`);
          if (pendingCandidates['viewer'].length > 0) {
            console.log(`Procesando candidatos pendientes para viewer...`);
            for (const candidate of pendingCandidates['viewer']) {
              await pc.addIceCandidate(new RTCIceCandidate(candidate));
              console.log(`Candidato ICE añadido para viewer`);
            }
            pendingCandidates['viewer'] = [];
          }
        } catch (error) {
          console.error(`Error manejando respuesta de ${fromId}:`, error);
        }
      } else {
        console.warn(`No se encontró peerConnection para el viewer`);
      }
    }

    async function handleCandidate(candidate, fromId) {
      const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
      if (pc) {
        try {
          if (!candidate || (!candidate.candidate && candidate.candidate !== '')) {
            console.warn(`Candidato ICE inválido de ${fromId}:`, candidate);
            return;
          }
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Candidato ICE añadido para ${fromId}`);
          } else {
            console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
            if (!pendingCandidates[fromId] && userRole === 'streamer') {
              pendingCandidates[fromId] = [];
            } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
              pendingCandidates['viewer'] = [];
            }
            (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
          }
        } catch (e) {
          console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
        }
      } else {
        console.warn(`No se encontró peerConnection para ${fromId}`);
      }
    }

    // Funciones de UI
    function showStream() {
      liveStreamVideo.style.visibility = 'visible';
      streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
      liveStreamVideo.style.visibility = 'hidden';
      streamPlaceholder.textContent = message;
      streamPlaceholder.style.display = 'block';
    }
  </script>
</body>
</html>